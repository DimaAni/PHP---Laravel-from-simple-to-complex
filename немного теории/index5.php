<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    body {
        background-color: wheat;
    }

    pre {
        color: red;
    }   
    </style>
    <title>Глава 5.</title>
</head>
<body>
    <h1>Функции.</h1>
    <p>
        Функции в PHP помогают делать код структурированным и упорядоченным. Делая 
        его более удобным для чтения и работы. Также помогают ипользовать код повторно.
    </p>
    <p>
        Ф-ии в PHP создаются с ключевого слова function далее идет имя ф-и затем параметры
        в круглых скобках(если они есть, иногда могут быть и пустыми). В круглых скобках
        параметров/аргументов может быть несколько. В этом случае они указываются через
        запятую.
    </p>
    <p>
        Сама ф-я представляет собой именованую часть  програмного кода, которую мы можем
        вызывать по имени. Ну или сказать по другому когда нам нужна определенная ф-я мы 
        просто указываем ее имя. Также следует учесть что при выполнении команд могут 
        обрабатываться различные значения.
    </p>
    <p>
        Аргументы ф-й являются аналогом переменных и схожи с теми значениями что и те 
        которые будут переданы ф-и при  ее вызове. Если у ф-и нет аргумента
        то скобки размещяем пустыми. Команды выполняемые при вызове ф-и находяться
        внутри фигурных скобок. Универсальный шаблон для ф-й выгдядит так.
    </p>
    <pre>
        // function имя аргумента {
            // Команда
        }
    </pre>
    <p>
        Команды в теле ф-и могут содержать обращение к аргументам ф-и, а аргументы ф-и 
        описываться как название переменных (название переменных начинается с $ символа).
    </p>
    <p>
        В дальнейшем когда ф-я вызывается ей передаются аргументы, выполняются команды 
        описаны теле ф-и. А где в програмном коде используется аргументы, ипользуется 
        фактическое значения, переданые ф-и при вызове.
    </p>
    <hr>
    <hr>
    <h3>Немного уточним о ф-ях.</h3>
    <p>
        Названия ф-ий не чуствительны к регистру. Тоесть написаное в разных местах кода
        одно и тоже название функции с маленькой или же большими буквами. Это будет 
        таже ф-я.
    </p>
    <p>
        Чтобы отличать ф-и от перменных, указываем после ф-и пустые скобки. Ну и перед
        перед переменными ставим символ $. Это избавит от путаницы и ускорит и 
        упростит читаемость кода.
    </p>
    <hr>
    <hr>
    <p>
    Простой пример ф-и:
    </p>
    <pre>
&lt;?php
// Описание ф-и.
function show($argyment) {
    echo "Вызов ф-и show()";
    echo "Тип аргумента: ", gettype($argyment);
    echo "Значение аргумента: $argyment";
}
// Вызов ф-и.
show(123);
SHOW("Изучаем PHP");
Show(2,5);

// В резульате выведется это:
// Вызов ф-и show()
// Тип аргумента: integer
// Значение аргумента: 123

// Вызов ф-и show()
// Тип аргумента: string
// Значение аргумента: Изучаем PHP

// Вызов ф-и show()
// Тип аргумента: integer
// Значение аргумента: 2
?&gt;
</pre>
<p>
    В примере выше описывается простая ф-я show(), с одним аргументом $argyment. 
    При вызове этой ф-и, в круглых скобках необходимо указать значение (аргумент ф-и).
</p>
<hr>
<hr>
<h3>Важно!</h3>
<p>
Важно понимать, что описание ф-и совсем незначит вызов ф-и. Для срабатывания кода
ф-и необходимо ее вызывать.
</p>
<p>
В дальнейщем будем придерживаться правила. Как мы описали ф-ю так и будем вызывать. 
(имеется в виду название функции).   
</p>
<hr>
<hr>
<h2>Результат ф-и.</h2>
<p>
    Ф-я возвращает результат. Результат ф-и - это значение которое остается нам на 
    долгую память, после того как ф-я завершила свое выполнение.
</p>
<p>
    Если ф-я возв-ет результат то инструкция которой вызывается  ф-я имеет значение
    и это значение - результат ф-и.
</p>
<p>
    Мы можем присвоить инструкцию вызова ф-и в кач-ве значения переменной или 
    ипользовать как операнд в более сложных выражениях.
</p>
<p>
    Чтобы показать в описании ф-и, что ф-я возвращает рез-т указываем инструкцию
    return. После возвращаемое ф-ей значение.
</p>
<hr>
<hr>
<h3>Уточним</h3>
<p>
    return - инструкция завершает выполнение ф-и. Код ф-и может иметь несколько 
    return - инструкций. К примеру в условном операторе. Но как только выполнится один
    из них. Работа ф-и завершится.
</p>
<p>
    Если ф-я не возвращает рез-т то для завершения выполнения такой ф-и можно использовать
    инструкцию return без указания возвращаемого значения. Или же return null.
</p>
<hr>
<hr>
<p>Несколько примеров ниже:</p>
<pre>
&lt;?php
// Функция для подсчета факториала числа с ипользованием рекурсии.
function factorial ($n) {
    if($n <=1) {
        return 1;
    }
    else{
        return $n * factorial($n - 1);
    }
}

$n = 5;
echo "Factorial of $n is " .factorial($n); // в результате будет Factorial of 5 is 120

?&gt;
</pre>

<pre>
&lt;?php

// Функция для возведения числа в степень:
    function power($x,$n){
        $s=1;
    for($k=1;$k<=$n;$k++){
    $s*=$x;
}
return $s;
}
echo power(2, 3); // Выведет 8

?&gt;

//Функция работает следующим образом:
//1.Инициализирует переменную $s значением 1.
//2.Запускает цикл от 1 до $n включительно.
//3.На каждой итерации цикла умножает $s на $x.
//4.После завершения цикла возвращает значение $s.

</pre>

<pre>
&lt;?php

// Функция для проверки числа на чет или не чет:

// Для этого можно использовать функцию is_even() или is_odd(). Вот пример с функцией is_even():
$num = 4;
if (is_even($num)) {
echo "Число чётное";
} else {
echo "Число нечётное";
}
?&gt;

</pre>
<hr>
<br>
<h2>Тип аргумента и результаты</h2>
<p>
    В предыдущих примерах мы расматривали то, что аргументы передаютя определенного типа. 
    также и с типом возвращаемого результата.
</p>
<p>
    Отсутствие явного указания на тип аргументов или тип результата не всегда является проблемой.
    В некоторых случаях это даже полезно, это позволяет создавать ф-и, 
    которые могут принимать аргументы разных типов. Но бывают и обратные ситуации,
    когда ф-я должна получать строго определённый тип аргумента. 
    Всё зависит от конкретной задачи.
</p>
<p>
    В тело ф-и можно добавить код, которым будет выполняться проверка 
    типа переданных аргументов. 
    Существует способ по проще. Это - «ограничить» спектр допустимых типов
    для аргументов: в описании ф-и для аргументов и результата ф-ии
    в явном виде указать их тип. Для аргументов тип указывается перед 
    названием аргумента в описании ф-и, а тип результата ф-и указывается 
    через двоеточие после закрывающей круглой скобки. Выглядит это так:
</p>
<pre>
function имя(тип аргумент, тип аргумент,…): тип{
 // Команды
}
</pre>
<p>
    Если же при таком виде описаия ф-ии попытаться вызвать ее или передать
    аргумент другово типа то произойдет ошибка.  
</p>
<h3>Важно!</h3>
<p>
    В PHP есть система перехвата и обработки иключений (ошибок) разных типов
    Она позволяет создавать программные коды, эффективно функционирующие 
    даже в случае возникновения ошибок.Пример ниже:
</p>
<pre>
&lt;?php
 // Для перехода в режим жесткой типизации нужно
 // отменить комментирование следующей инструкции:

# declare(strict_types=1);

 // Явно указан тип аргументов и тип результата:

function power(float $x, int $n): string {

for($s=1,$k=1;$k<=$n;$s*=$x,$k++);

return "Число $x в степени $n: ".$s."\n";

}
 // Вызов функции:
echo power(3,4);
echo power(1.5,2.7);
echo power("2","10.1");

// В результате будет выведено это:

// Число 3 в степени 4: 81
// Число 1.5 в степени 2: 2.25
// Число 2 в степени 10: 1024

?&gt;
</pre>
<p>
    C версии PHP 8 и последующие за ней появилась возможность задавать объединение типов. 
    В этом случае типы перечисляются с помощщью вертикальной черты | в виде разделителя. 
</p>
<p>
    int | string | double, это значит что соответствующая переменная (аргумент функции или
    ее результат) может относится к типу int,string или double.
</p>
<p>
    Также есть тип mixed представляющий собой большое объединение типов.
</p>
<hr>
<br>
<h2>Механизм передачи аргументов.</h2>
<p>
Чтобы понять суть следующей проблемы, рассмотрим пример ниже.
</p>
<pre>
&lt;?php

// Функция с двумя аргументами:
    function swap($a,$b) {

    echo "Вход: аргументы $a и $b\n";
    $x=$a;
    $a=$b;
    $b=$x;
    echo "Выход: аргументы $a и $b\n";
    }
// Переменные:
    $A=100;
    $B=200;
// Значение переменных:

    echo "\$A = $A и \$B = $B\n";

// Вызываем функцию:
    swap($A,$B);

// Проверка значений переменных:

    echo "\$A = $A и \$B = $B\n";

// Результат выведется таким. 


//$A = 100 и $B = 200
//Вход: аргументы 100 и 200
//Выход: аргументы 200 и 100
//$A = 100 и $B = 200

?&gt;
</pre>

<p>Действия нашего примера выше заключается в следующих шагах</p>
<p>
    В данном примере ф-и  swap () у нас два аргумента. При вызове ф-и отображаются
    значения аргументов (первому аргументу присвоили значение второго. А второму первое).
    Далее проверили его.
</p>
<p>
    Мы используем две переменные $A и $B со значениями 100 и 200. 
    Сначала проверяются значения этих переменных, затем переменные передаются аргументами
    функции swap() (команда swap($A,$B)), и снова проверяются значения переменных.
</p>
<p>
    Как мы видим, переменные $A и $B не изменили своих значений, хотя при второй проверке
    значений аргументов в теле функции swap() аргументы вроде бы обменялись значениями.
    В чем причина и как понимать эту ситуацию? На самом деле все логично, если учесть, 
    что при передаче аргументов функции передаются не сами переменные, а их копии. 
    Другими словами, при выполнении команды swap($A,$B) в функцию swap() передаются 
    не переменные $A и $B, а их копии. Именно копии обмениваются значениями
    в процессе выполнения кода функции swap(). После завершения выполнения функции 
    копии аргументов удаляются из памяти, а переменные $A и $B остаются со своими прежними
    значениями. Такой механизм передачи аргументов используется по умолчанию и называется 
    передачей аргументов по значению. 
</p>
<p>
    Расмотрим другой пример, здесь аргументы передаются по ссылке.
</p>

<pre>
&lt;?php
// Передача аргументов по ссылке:
    function swap(&$a,&$b) {

    echo "Вход: аргументы $a и $b\n";
    $x=$a;
    $a=$b;
    $b=$x;
    echo "Выход: аргументы $a и $b\n";
}
    $A=100;
    $B=200;
    echo "\$A = $A и \$B = $B\n";
    swap($A,$B);
    echo "\$A = $A и \$B = $B\n";

// Результат выведется такой.
// $A = 100 и $B = 200
// Вход: аргументы 100 и 200
// Выход: аргументы 200 и 100
// $A = 200 и $B = 100
?&gt;
</pre>
<p>
    Здесь получилось что значения переменных $A и $B изменились после того, 
    как эти переменные были переданы аргументами функции swap().
</p>
<hr>
<br>
<h2>Значения аргументов по умолчанию</h2>
<p>
    Чтобы задать для аргумента значение по умолчанию. Нужно функции для требуемого
    аргумента указать значение по умолчанию через оператор присваивания после имени 
    аргумента. При этом аргументы, имеющие значения по умолчанию, должны быть 
    описаны в списке аргументов функции последними.
</p>
<p>
    Ну а если простыми словами. Сначало опишем аргументы без значений по умолчанию
    а затем со значениями по умолчанию.
</p>
<p>
    Примеры со значениями аргументов по умолчанию.
</p>
<pre>
&lt;?php
// Все аргументы ф-и имеют значение по умолчанию.
function show(first="Alfa" ;$second="Bravo") {
    echo "Первый аргумент: ",$first,"\n";
    echo "Первый аргумент: ",$second,"\n\n";
}
// Не все аргументы функции
// имеют значения по умолчанию:

function display($x,$y=200,$z=300){
echo "Первое число: ",$x,"\n";
echo "Второе число: ",$y,"\n";
echo "Третье число: ",$z,"\n\n";
}
 // Вызов функций:
show(); # Без аргументов

show("A"); # Один аргумент
show("A","B"); # Два аргумента
display(100); # Один аргумент
display(1,2); # Два аргумента
display(1,2,3); # Три аргумента

//Результат выведется таким
Первый аргумент: A
Первый аргумент: Bravo
Первый аргумент: A
Первый аргумент: B
Первое число: 100
Второе число: 200
Третье число: 300
Первое число: 1
Второе число: 2
Третье число: 300
Первое число: 1
Второе число: 2
Третье число: 3

?&gt;
</pre>
<h2>Произвольное количество аргументов</h2>
<p>В PHP при вызове ф-и можно передать аргументов больше чем есть в описании ф-и</p>
<p>
    Допустим если мы описали ф-ю с двумя аргументами то вызывая ее мы передаем ей пять
    аргументов.
</p>
<p>
    Этим можно воспользоваться создвая ф-и с любым кол-вом арг-в. Тоесть если мы взываем ф-ю
    с любыи кол-вом арг-в, то они все обрабатываются в ф-ии. 
</p>
<p>
    Для обработки аргументов ф-ии не указааных в описанни ф-ии, можно применить такие ф-ии
    как func_get_args() ->(Получает спиок переданных арументов). У этой ф-ии нет аргументов.
    Ее результом будет список арг-в переданной ф-ии в теле которой она вызвана.
</p>
<p>
    Также еще существуют func_num_args( ) ->(Возвращает кол-во переданных арг-в вызываемых в теле) и
    ф-я func_get_arg( ) ->(возвращает значение аргумента  ф-ии в в теле 
    которой она указана с определенным индексом).
</p>
<p>
    Пример с ипользованием ф-ии func_get_args( )
</p>
<pre>
&lt;?php
function sum( ) {
    $args = func_get_args( );
    $total = 0;
    foreach ($args as $num) {
        $total += $num;
    }
    return $total;
}

echo sum(1, 2, 3, 4, 5); // Вывод: 15
?&gt;
</pre>
<p>
    Пример с ф-ей func_get_arg( )
</p>
<pre>
&lt;?php
function foo() {

    $numargs = func_num_args();
    echo "Количество аргументов: $numargs";
    if ($numargs >= 2) {
        echo "Второй аргумент: ". func_get_arg(1). "";
    }
}

foo(1, 2, 3);
//Ф-я foo использует func_num_args() для получения количества аргументов, переданных в ф-ю, 
//и func_get_arg(1) для доступа ко второму аргументу. Это позволяет продемонстрировать
//работу с произвольным количеством аргументов и их обработку внутри функции.
?&gt;
</pre>
<hr>
<br>
<h2>Рекурсия</h2>
<p>
Коротко это ф-я которая выводит сама себя
</p>
<p>
    Пример с рекурсией
</p>
<pre>
&lt;?php
function factorial($n) {
    if (!$n) {
        return 1;
    } else {
        return $n * factorial($n - 1);
    }
}

echo factorial(5); // Выведет 120

//Этот код определяет функцию factorial, которая принимает число $n в качестве аргумента. 
//Если $n равно нулю, функция возвращает 1. В противном случае она умножает $n на результат
//вызова самой себя с аргументом $n - 1. 

?&gt;
</pre>
<hr>
<br>
<h2>Функция eval()</h2>
<p>
Функция eval() в PHP используется для вычисления строки как PHP-кода. Это может быть полезно,
например, для хранения PHP-кода в базе данных и его последующего выполнения.
</p>
<p>Пример с eval()</p>
<pre>
&lt;?php
$string = 'Это утро по времени $string $!';
$time = 'зима';
$str = 'Это утро в ' . $string . ' зима!';
echo $str . "<br>";
eval('$str = "' . $str . '";');
echo $str;


//Cтрока $str содержит PHP-код, который выводит фразу «Это утро по времени зима!». 
//Затем этот код выполняется с помощью функции eval(), и результат выводится на экран.
//Обратите внимание, что использование eval() может представлять угрозу безопасности, 
//поскольку позволяет выполнять произвольный код, предоставленный пользователем. 
//Поэтому следует избегать его использования, если это возможно.

?&gt;
</pre>
<hr>
<br>
<h2>Анонимные ф-ии</h2>
<p>
Анонимные ф-ии в PHP, также известные как замыкания (closures), позволяют создавать 
ф-ии без явного имени. Они особенно полезны в качестве значений callback-параметров,
но также имеют множество других применений. Вот несколько примеров их использования:
</p>
<p>
    Пример анонимной ф-ии.
</p>
<pre>
&lt;?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    
    return strtoupper($match[1]);
}, 'hello-world'); // выведет helloWorld

//В этом примере анонимная функция используется для преобразования строчных 
//букв в прописные после дефиса в строке.

?&gt;
</pre>
<p>
Присвоение анонимной функции переменной:
</p>


<pre>
&lt;?php
$greet = function($name) {
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');

//Здесь мы создаем анонимную ф-ю, присваиваем её переменной $greet, а затем вызываем 
//эту ф-ю дважды с разными аргументами.
?&gt;
</pre>
<p>
Наследование переменных из родительской области видимости:
</p>

<pre>
&lt;?php
$message = 'hello'; // Без "use"
$example = function () {
    var_dump($message);
};
echo $example(); // Наследуем $message

$example = function () use ($message) {
    var_dump($message);
};
echo $example(); // Теперь используем "use"
?&gt;
</pre>
<hr>
<br>
<h2>Именованные аргументы.</h2>
<p>
Именованные аргументы в PHP позволяют передавать аргументы в функции, используя 
их имена, а не позиции. Это делает код более читаемым и снижает вероятность 
передачи неверного значения неверному параметру.
</p>
<p>
Пример использования именованных аргументов:    
</p>
<pre>
&lt;?php
function myFunction(string $name, int $age) {
    echo "Имя: {$name}<br>";
    echo "Возраст: {$age} лет<br>";
}

myFunction(age: 25, name: 'Иван');

//Здесь мы передаём аргументы ф-ии myFunction с использованием их имён (age и name),
//а не позиций. Это позволяет легко понять, какой аргумент соответствует какому 
//параметру, даже если порядок аргументов в вызове ф-ии отличается от порядка 
//параметров в определении ф-ии. Именованные аргументы особенно полезны в случаях, 
//когда есть ф-ия с большим количеством параметров, и хотим передать только некоторые
//из них, не беспокоясь о порядке их передачи. Они также помогают избежать ошибок, 
//связанных с неправильным порядком аргументов, что может произойти, если работаем с ф-ми,
//имеющими много параметров.
?&gt;
</pre>


<pre>
&lt;?php

?&gt;
</pre>


</body>
</html>