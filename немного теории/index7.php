<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    body {
        background-color: wheat;
        color: black;
    }

    pre {
        color: red;
    }

    .ul pre {
        font-size: 18px;
        color: black;
    }
    
    </style>
    <title>Глава. 7</title>
</head>
<body>
    <h1>Классы и объекты.</h1>
    <h2>Принципы ООП.</h2>
<p>
    Объектно-ориентированное программирование (ООП) — это методология программирования, 
    основанная на представлении программы в виде совокупности объектов, каждый из которых 
    является экземпляром определённого класса, а классы образуют иерархию наследования. 
    ООП позволяет моделировать реальные сущности и процессы, представляя их в виде объектов,
    которые взаимодействуют друг с другом, посылая сообщения.
</p>
<p>
Основные принципы ООП включают:
</p>
<ul>
<li>
    Инкапсуляцию — объединение данных и методов внутри объекта, обеспечивая защиту данных 
    от несанкционированного доступа.
</li>
<li>
    Наследование — возможность создания новых классов на основе существующих, наследуя их 
    свойства и методы.
</li>
<li>
    Полиморфизм — возможность использования одного и того же имени метода для 
    различных действий в зависимости от типа объекта.
</li>
</ul>
<p>Принципы ООП разрабатывались для больших программ.</p>
<p>Большая программа это несколько тысящ строк кода.</p>
<p>Программа написаная в рамках ООП подразумевает за собой создание объектов.</p>
<p>Объекты создаются на основе шаблонов. И они соответственно называютя классами.</p>
<br>
<p>
    Вернемся к инкапсуляции, наследовании и полиморфизму.Это три базовых мехнизма OOP.
</p>
<p>
    Инкапсуляция подразумевает за собой что данные и код для из обработки объединяются в одно 
    целое в объект.
</p>
<p>
    Наследование позволяет создавать новые классы используя существующие и наследуя их св-ва.  
</p>
<p>
    Полиморфизм - это использование универсальных интерфейсов взаимодействия с объектами, функциями и 
    методами.
</p>
<hr>
<br>
<h2>Создание классов и объектов.</h2>
<p>Создание класса начинается с ключевого слова class затем имя класса. Дальше в блоке выделеннным
    фигурными скобками указываем содержание класса.Шаблон класса ниже:
</p>
<pre>
    class имя {
        #Содержание класса
    }
</pre>
<p> 
    В классе можно описать методы и поля. Поля - это пере-е. Поля также называют 
    <strong>свойствами или атрибутами</strong>. Разница от обычных переменных у полей в 
    том что они описываются в классе и им ненадо присваивать значение - достаточно просто их наличие. 
</p>
<p>
    Пример с одним полем:
</p>
<pre>
    class MyClass {
        public $number: 
    }
</pre>
<p>
    Здесь всего одна инструкция в теле класса public, $number означает описание поля с название $number.
</p>
<p>
    public - это спецификатор уровня доступа и он означает, что это открытое поле.
</p>
<p>
    Открытое поле дает доступ к самому полю как внутри так и с наружи класса.
</p>
<p>
    Кроме спецификатора public, могут использоваться ключевые слова как private(закрытое) или же
    protected(защищенное поле).
</p>
<p>Чтобы создать на  основе класса объект применяем инструкцию new, затем пишем имя класса на основе
    которого хотим создать класс. 
</p>
<p>
    Ссылка на этот объект пишеться в переменную(объектная переменная), которая отождествляется с объектом.
</p>
<p>Вот пример шаблона создания объекта:</p>
<pre>
$переменная=new Kласс;
</pre>
<p>
    Для примера если мы хотим создать объект класса  MyClass.То это будет так.
</p>
<p>
    $obj=new MyClass;
</p>
<p>
    Такой командой мы создали объект класса MyClass. Ссылка же записывается в переменную $obj.
</p>
<p>
    А чтобы получить доступ к объекту применяем переменную $obj.
</p>
<p>
    Объект это прежде всего его поля и методы. Поэтому чтобы получить доступ к его полям и методам, 
    мы указывае такую стрелку -> . Она указывается после объектной переменной, за ней название поля 
    без символа $ . 
</p>
<p>
    Вот небольшой пример как это выглядит:
</p>
<pre>
&lt;?php
//описание класса: 
class MyClass {
    public
}
//создание объекта: 
$obj=new MyClass; 
//полю объекта присваивается значение: 
$obj->number=123; 
//отображение значения поля: 
echo "Поле \$number: $obj->number\n"; 
//новое значение поля: 
$obj->number=321;
//отображение значения поля: 
echo "Поле \$number: $obj->number\n";
//результат будет таким 
//Поле $number: 123
//Поле $number: 321
?&gt;
</pre>
<hr>
<br>
<h2>Методы</h2>
<p>
    Методы можно описывать как функции, но только внутри класса.Основная особенность метода. 
    Это то - как методы вызывается. Если для вызова ф-и достаточно указать имя  ф-и и список аргументов. 
    То в случае вызова метода необходимо указать еще и объект с которого мы вызываем необходимый метод. 
    Метод имеет доступ ко всем полям и методам описанных в классе.
</p>
<p>Небольшой пример использования метода</p>
<pre>
&lt;?php
class Tag {
public function setAttrs($attrs) {
foreach ($attrs as $name => $value) {
$this->setAttr($name, $value);
}
return $this;
}
public function setAttr($name, $value) {
 // Реализация метода setAttr
}
public function open() {
 // Реализация метода open
}
}

$tag = new Tag('input');
echo $tag->setAttrs(['id' => 'test', 'class' => 'eee'])
->setAttr('type', 'text')
->open(); // выведет <input id="test" class="eee" type="text">


//В этом примере мы используем два метода класса Tag: setAttrs и setAttr. Метод setAttrs принимает
//массив атрибутов и устанавливает их все с помощью метода setAttr. Затем мы используем метод 
//setAttr для установки конкретного атрибута type со значением text. Наконец, мы вызываем метод
//open, который выводит тег с установленными атрибутами.
?&gt;
</pre>
<hr>
<br>
<h2>Конструкторы и Деструкторы</h2>
<p>
Конструктор (__construct) вызывается при создании нового объекта, позволяя инициализировать его свойства.
Деструктор (__destruct) вызывается автоматически, когда объект теряет последнюю ссылку на него и 
должен быть освобожден из памяти.
</p>
<p>
    Пример с __construct
</p>
<pre>
&lt;?php
class Person {
public $name, $age;
function __construct($name, $age) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
}
$tom = new Person("Иван", 33);
$tom->displayInfo();

//В этом примере конструктор принимает два параметра: имя и возраст, и присваивает 
//их соответствующим свойствам объекта.
?&gt;
</pre>
<p>
    Пример с __destruct
</p>
<pre>
&lt;?php
class Person {
public $name, $age;
function __construct($name, $age) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
function __destruct() {
echo "Вызов деструктора";
}
}
//Здесь деструктор просто выводит сообщение о своем вызове. Важно понимать, 
//что деструктор вызывается автоматически, когда объект больше не используется
//в программе и должен быть освобожден из памяти.
?&gt;
</pre>
<p>
Использование параметров по умолчанию в конструкторе:    
</p>

<pre>
&lt;?php
class Person {
public $name, $age;
function __construct($name = "Иван", $age = 33) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
}
$иван = new Person();
$иван->displayInfo();
//В этом примере параметры конструктора имеют значения по умолчанию, что позволяет 
//создавать объекты без указания всех параметров.
?&gt;
<p>
Объявление свойств через конструктор:
</p>
<pre>
&lt;?php
class Person {
function __construct(public $name, public $age) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
}
$tom = new Person("Иван", 33);
$tom->displayInfo();
//В этом примере параметры конструктора с модификатором доступа public автоматически 
//становятся свойствами класса.
?&gt;
</pre>
<p>
    Если аргументы констуктору не передаются, то после имени класса в команде создания объекта 
    ставятся пустые скобки. Также можно обойтись и без них. 
</p>
<hr>
<br>
<h2>Статические поля и методы.</h2>
<p>
    Для  создания cтатические поля и cтатических методов пишем ключевое слово static.
</p>
<p>
    В чем разница между статическими полями и методами от обычных (не статичных полей и методов)?
</p>
<p>
    Разница заключается в том, что НЕ статичные привзязаны к объекту а статичные члены класса 
    ни к какому объекту не относятся. 
</p>
<p>
    Для обращения к статическому полю, методу класса, - указываем сначало имя класса 
    затем двойное двоеточие :: и затем имя метода класса или имя статического поля (с аргументами внутри
    круглых скобках). Если обращение происходит внутри кода класса, то вместо названия класса указывем
    идентификатор self. 
</p>
<pre>
&lt;?php
class Math {
    private static $count = 0; // статическое поле

    public static function calcSin($x) {
        return sin($x); // статический метод
    }

    public static function calcSQRT($x) {
        return sqrt($x); // статический метод
    }

    public static function getCount() {
        return self::$count; // доступ к статическому полю через self
    }

    public function __construct() {
        self::$count++; // увеличение статического поля при создании объекта
    }
}

echo Math::calcSin(1); // вызов статического метода
echo "<br />";
echo Math::calcSQRT(9); // вызов статического метода
echo "<br />";

$math = new Math(); // создание объекта
$math_2 = new Math(); // создание второго объекта

echo Math::getCount(); // получение значения статического поля
// Здесь показано использование статических полей и методов в классе Math.
?&gt;
</pre>
<p>
    Статические поля и методы принадлежат классу, а не объектам, и могут быть 
    вызваны напрямую через имя класса, без необходимости создания экземпляра объекта.
</p>
<hr>
<br>
<h2>Копирование объектов</h2>
<p>Как произвести копирование объекта?</p>
<p>Вот небольшой пример</p>
<pre>
&lt;?php

?&gt;
</pre>




</body>
</html>