<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    body {
        background-color: wheat;
        color: black;
    }

    pre {
        color: red;
    }

    .ul pre {
        font-size: 18px;
        color: black;
    }
    
    </style>
    <title>Глава. 7</title>
</head>
<body>
    <h1>Классы и объекты.</h1>
    <h2>Принципы ООП.</h2>
<p>
    Объектно-ориентированное программирование (ООП) — это методология программирования, 
    основанная на представлении программы в виде совокупности объектов, каждый из которых 
    является экземпляром определённого класса, а классы образуют иерархию наследования. 
    ООП позволяет моделировать реальные сущности и процессы, представляя их в виде объектов,
    которые взаимодействуют друг с другом, посылая сообщения.
</p>
<p>
Основные принципы ООП включают:
</p>
<ul>
<li>
    Инкапсуляцию — объединение данных и методов внутри объекта, обеспечивая защиту данных 
    от несанкционированного доступа.
</li>
<li>
    Наследование — возможность создания новых классов на основе существующих, наследуя их 
    свойства и методы.
</li>
<li>
    Полиморфизм — возможность использования одного и того же имени метода для 
    различных действий в зависимости от типа объекта.
</li>
</ul>
<p>Принципы ООП разрабатывались для больших программ.</p>
<p>Большая программа это несколько тысящ строк кода.</p>
<p>Программа написаная в рамках ООП подразумевает за собой создание объектов.</p>
<p>Объекты создаются на основе шаблонов. И они соответственно называютя классами.</p>
<br>
<p>
    Вернемся к инкапсуляции, наследовании и полиморфизму.Это три базовых мехнизма OOP.
</p>
<p>
    Инкапсуляция подразумевает за собой что данные и код для из обработки объединяются в одно 
    целое в объект.
</p>
<p>
    Наследование позволяет создавать новые классы используя существующие и наследуя их св-ва.  
</p>
<p>
    Полиморфизм - это использование универсальных интерфейсов взаимодействия с объектами, функциями и 
    методами.
</p>
<hr>
<br>
<h2>Создание классов и объектов.</h2>
<p>Создание класса начинается с ключевого слова class затем имя класса. Дальше в блоке выделеннным
    фигурными скобками указываем содержание класса.Шаблон класса ниже:
</p>
<pre>
    class имя {
        #Содержание класса
    }
</pre>
<p> 
    В классе можно описать методы и поля. Поля - это пере-е. Поля также называют 
    <strong>свойствами или атрибутами</strong>. Разница от обычных переменных у полей в 
    том что они описываются в классе и им ненадо присваивать значение - достаточно просто их наличие. 
</p>
<p>
    Пример с одним полем:
</p>
<pre>
    class MyClass {
        public $number: 
    }
</pre>
<p>
    Здесь всего одна инструкция в теле класса public, $number означает описание поля с название $number.
</p>
<p>
    public - это спецификатор уровня доступа и он означает, что это открытое поле.
</p>
<p>
    Открытое поле дает доступ к самому полю как внутри так и с наружи класса.
</p>
<p>
    Кроме спецификатора public, могут использоваться ключевые слова как private(закрытое) или же
    protected(защищенное поле).
</p>
<p>Чтобы создать на  основе класса объект применяем инструкцию new, затем пишем имя класса на основе
    которого хотим создать класс. 
</p>
<p>
    Ссылка на этот объект пишеться в переменную(объектная переменная), которая отождествляется с объектом.
</p>
<p>Вот пример шаблона создания объекта:</p>
<pre>
$переменная=new Kласс;
</pre>
<p>
    Для примера если мы хотим создать объект класса  MyClass.То это будет так.
</p>
<p>
    $obj=new MyClass;
</p>
<p>
    Такой командой мы создали объект класса MyClass. Ссылка же записывается в переменную $obj.
</p>
<p>
    А чтобы получить доступ к объекту применяем переменную $obj.
</p>
<p>
    Объект это прежде всего его поля и методы. Поэтому чтобы получить доступ к его полям и методам, 
    мы указывае такую стрелку -> . Она указывается после объектной переменной, за ней название поля 
    без символа $ . 
</p>
<p>
    Вот небольшой пример как это выглядит:
</p>
<pre>
&lt;?php
//описание класса: 
class MyClass {
    public
}
//создание объекта: 
$obj=new MyClass; 
//полю объекта присваивается значение: 
$obj->number=123; 
//отображение значения поля: 
echo "Поле \$number: $obj->number\n"; 
//новое значение поля: 
$obj->number=321;
//отображение значения поля: 
echo "Поле \$number: $obj->number\n";
//результат будет таким 
//Поле $number: 123
//Поле $number: 321
?&gt;
</pre>
<hr>
<br>
<h2>Методы.</h2>
<p>
    Методы можно описывать как функции, но только внутри класса.Основная особенность метода. 
    Это то - как методы вызывается. Если для вызова ф-и достаточно указать имя  ф-и и список аргументов. 
    То в случае вызова метода необходимо указать еще и объект с которого мы вызываем необходимый метод. 
    Метод имеет доступ ко всем полям и методам описанных в классе.
</p>
<p>Небольшой пример использования метода</p>
<pre>
&lt;?php
class Tag {
public function setAttrs($attrs) {
foreach ($attrs as $name => $value) {
$this->setAttr($name, $value);
}
return $this;
}
public function setAttr($name, $value) {
 // Реализация метода setAttr
}
public function open() {
 // Реализация метода open
}
}

$tag = new Tag('input');
echo $tag->setAttrs(['id' => 'test', 'class' => 'eee'])
->setAttr('type', 'text')
->open(); // выведет <input id="test" class="eee" type="text">


//В этом примере мы используем два метода класса Tag: setAttrs и setAttr. Метод setAttrs принимает
//массив атрибутов и устанавливает их все с помощью метода setAttr. Затем мы используем метод 
//setAttr для установки конкретного атрибута type со значением text. Наконец, мы вызываем метод
//open, который выводит тег с установленными атрибутами.
?&gt;
</pre>
<hr>
<br>
<h2>Конструкторы и Деструкторы</h2>
<p>
Конструктор (__construct) вызывается при создании нового объекта, позволяя инициализировать его свойства.
Деструктор (__destruct) вызывается автоматически, когда объект теряет последнюю ссылку на него и 
должен быть освобожден из памяти.
</p>
<p>
    Пример с __construct
</p>
<pre>
&lt;?php
class Person {
public $name, $age;
function __construct($name, $age) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
}
$tom = new Person("Иван", 33);
$tom->displayInfo();

//В этом примере конструктор принимает два параметра: имя и возраст, и присваивает 
//их соответствующим свойствам объекта.
?&gt;
</pre>
<p>
    Пример с __destruct
</p>
<pre>
&lt;?php
class Person {
public $name, $age;
function __construct($name, $age) {
$this->name = $name;
$this->age = $age;
}
function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
function __destruct() {
echo "Вызов деструктора";
}
}
//Здесь деструктор просто выводит сообщение о своем вызове. Важно понимать, 
//что деструктор вызывается автоматически, когда объект больше не используется
//в программе и должен быть освобожден из памяти.
?&gt;
</pre>
<p>
Использование параметров по умолчанию в конструкторе:    
</p>

<pre>
&lt;?php
class Person {
public $name, $age;

function __construct($name = "Иван", $age = 33) {
$this->name = $name;
$this->age = $age;
}

function displayInfo() {
echo "Name: {$this->name}; Age: {$this->age}<br>";
}
}

$иван = new Person();
$иван->displayInfo();
//Этот код создаёт класс Person, который имеет два публичных свойства: $name и $age. 
//Метод __construct() используется для инициализации этих свойств при создании 
//нового объекта. Если при создании объекта не указаны значения для $name и $age, 
//то используются значения по умолчанию: «Иван» для $name и 33 для $age.
//Метод displayInfo() выводит информацию о человеке на экран.
//Затем создаётся объект $иван класса Person. Так как при создании объекта не 
//были указаны значения для $name и $age, то используются значения по умолчанию. 
//После этого вызывается метод displayInfo(), который выводит информацию об этом человеке на экран.
?&gt;
</pre>

<br>

//Теперь объявление свойств через конструктор:

<pre>
&lt;?php
class Person {
    public $name;
    public $age;

    public function __construct($name, $age) {
        $this->name = $name;
        $this->age = $age;
    }

    public function displayInfo() {
        echo "Name: {$this->name}; Age: {$this->age}<br>";
    }
}

$егор = new Person("Егор", 13);
$егор->displayInfo();

//Этот код создаёт класс Person, который имеет два публичных свойства: $name и $age. 
//Метод __construct() используется для инициализации этих свойств при создании нового объекта.
//Метод displayInfo() выводит информацию о человеке на экран.
//Затем создаётся объект $егор класса Person с именем «Егор» и возрастом 13 лет. 
//После этого вызывается метод displayInfo(), который выводит информацию об этом человеке на экран.
?&gt;
</pre>
<p>
    Если аргументы констуктору не передаются, то после имени класса в команде создания объекта 
    ставятся пустые скобки. Также можно обойтись и без них. 
</p>
<hr>
<br>
<h2>Статические поля и методы.</h2>
<p>
    Для  создания cтатические поля и cтатических методов пишем ключевое слово static.
    В чем же разница между статическими полями и методами от обычных (не статичных полей и методов)?
    Разница заключается в том, что НЕ статичные привзязаны к объекту а статичные члены класса 
    ни к какому объекту не относятся. 
</p>
<p>
    Для обращения к статическому полю, методу класса, - указываем сначало имя класса 
    затем двойное двоеточие :: и затем имя метода класса или имя статического поля (с аргументами внутри
    круглых скобках). Если обращение происходит внутри кода класса, то вместо названия класса указывем
    идентификатор self. 
</p>
<pre>
&lt;?php
class Math {
    private static $count = 0; // статическое поле

    public static function calcSin($x) {
        return sin($x); // статический метод
    }

    public static function calcSQRT($x) {
        return sqrt($x); // статический метод
    }

    public static function getCount() {
        return self::$count; // доступ к статическому полю через self
    }

    public function __construct() {
        self::$count++; // увеличение статического поля при создании объекта
    }
}

echo Math::calcSin(1); // вызов статического метода
echo "<br />";
echo Math::calcSQRT(9); // вызов статического метода
echo "<br />";

$math = new Math(); // создание объекта
$math_2 = new Math(); // создание второго объекта

echo Math::getCount(); // получение значения статического поля
// Здесь показано использование статических полей и методов в классе Math.
?&gt;
</pre>
<p>
    Статические поля и методы принадлежат классу, а не объектам, и могут быть 
    вызваны напрямую через имя класса, без необходимости создания экземпляра объекта.
</p>
<hr>
<br>
<h2>Копирование объектов.</h2>
<p>
    Как создать копирование объекта? Самый простой способ - это ипользовать инструкцию clone 
    в команде присваиваивания объектов.
</p>
<p>Вот небольшой пример</p>
<pre>
&lt;?php
class Myclass{
public $code;
function __construct($code) {
    $this->code=$code;
}
    function show() {
        echo "Поле \$code: ",$this->code,"\n";
    }
}
$A=new MyClass(100);
echo "Объект \$A\n";

#копировавние объекта: 

$B=clone $A;
echo "Объект \$B\n";

$B->show();
$A->code=200;

echo "Объект \$A\n";
$A->show();

echo "Объект \$B\n";
$B->show();

//Результат получиться таким:
//Oбъект $A;
//Поле $code: 100;

//Oбъект $B;
//Поле $code: 100;

//Oбъект $A;
//Поле $code: 200;

//Oбъект $B;
//Поле $code: 100;

//В результате мы дейсвительно увидели что код копируется
?&gt;
</pre>
<hr>
<br>
<h2>Закрытые поля и методы.</h2>
<p>
Закрытые поля и методы используются для ограничения доступа к определённым частям класса.
Они помогают обеспечить инкапсуляцию данных и методов, делая их доступными только внутри класса.
</p>
<p>
Закрытые поля объявляются с использованием модификатора доступа private. Такие поля доступны 
только внутри класса, в котором они определены, и не могут быть доступны или изменены извне класса.    
</p>
<pre>
&lt;?php
class Person {
private $name;
private $age;

public function __construct($name, $age) {
$this->name = $name;
$this->age = $age;
}

public function getName() {
return $this->name;
}

public function getAge() {
return $this->age;
}
}
//В этом примере поля $name и $age являются закрытыми, что означает, что они недоступны за 
//пределами класса Person.
?&gt;
</pre>
<p>
Закрытые методы.
Закрытые методы также объявляются с использованием модификатора доступа private. 
Они доступны только внутри класса, в котором они определены, и не могут быть вызваны извне класса.
</p>
<pre>
&lt;?php
class Person {
private function setName($name) {
$this->name = $name;
}

public function getName() {
return $this->name;
}
}
//В этом примере метод setName() является закрытым, что означает, что он может быть вызван только 
//внутри класса Person.
//Использование закрытых полей и методов помогает обеспечить инкапсуляцию данных и методов, 
//делая код более надёжным и безопасным.
?&gt;
</pre>
<hr>
<br>
<h2>
    Специальные методы.
</h2>
<p>
Специальные методы в PHP, известные как магические методы, представляют собой функции, 
начинающиеся с двойного подчёркивания (__) и играющие ключевую роль в 
объектно-ориентированном программировании. Эти методы позволяют разработчикам динамически обрабатывать
события и операции в классах, модифицируя поведение классов для адаптации под конкретные нужды.
Вот некоторые часто используемые магические методы:
</p>
<ol>
<li>
__construct(): Этот метод является конструктором класса и автоматически вызывается при создании объекта.
Используется для инициализации свойств объекта и выполнения любых необходимых настроек.
</li>
<p>
// Пример использования метода __construct()
</p>
<pre>
&lt;?php
class MyClass {
    public function __construct() {
        echo "Конструктор вызван!\n";
    }
}

$myObject = new MyClass();
?&gt;
</pre>
<br>
<li>
__destruct(): Вызывается автоматически, когда объект больше не доступен или когда скрипт завершает 
выполнение. Применяется для выполнения очистки ресурсов, удерживаемых объектом.    
</li>
<pre>
&lt;?php
class MyClass {
    public function __destruct() {
        echo "Объект уничтожен.\n";
    }
}

$myObject = new MyClass();
// Объект больше не доступен.
// В этом примере при уничтожении объекта $myObject будет выведен текст “Объект уничтожен”. 
// Это позволяет выполнить очистку ресурсов, связанных с объектом, перед его уничтожением.
?&gt;
</pre>
<br>
<li>
__get() и __set(): Работают с доступом к свойствам объекта, которые могут быть недоступны или неопределены.
Позволяют определить пользовательскую логику для получения или установки значений свойств.    
</li>
<p>
Пример использования методов __get() и __set():
</p>
<pre>
&lt;?php
class MyClass {
private $data = [];

public function __get($propertyName) {
if (array_key_exists($propertyName, $this->data)) {
return $this->data[$propertyName];
} else {
throw new Exception("Свойство '$propertyName' не найдено.");
}
}

public function __set($propertyName, $value) {
$this->data[$propertyName] = $value;
}
}

$myObject = new MyClass();
$myObject->name = "John Doe"; // Вызов __set() для установки значения свойства
echo $myObject->name; // Вызов __get() для получения значения свойства

//В этом примере метод __get() проверяет наличие свойства в массиве $data и возвращает его значение,
//если оно существует. Если свойство не найдено, генерируется исключение. Метод __set() 
//устанавливает значение свойства в массив $data. Это позволяет контролировать доступ к 
//свойствам объекта и обеспечивает дополнительную защиту данных.
?&gt;
</pre>
<br>
<li>
__isset() и __unset(): Используются при работе с функциями isset() и unset(), позволяя определить 
пользовательскую логику для проверки существования или удаления свойств объекта.    
</li>
<p>
Пример использования методов __isset() и __unset():    
</p>
<pre>
&lt;?php
class MyClass {
public function __isset($propertyName) {
if (array_key_exists($propertyName, $this->data)) {
return true;
} else {
return false;
}
}

public function __unset($propertyName) {
unset($this->data[$propertyName]);
}
}

$myObject = new MyClass();
if (isset($myObject->name)) {
echo "Переменная 'name' существует.";
} else {
echo "Переменная 'name' не существует.";
}
unset($myObject->name); // Вызов метода __unset() для удаления переменной

//В этом примере метод __isset() проверяет существование свойства name в объекте $myObject. 
//Если свойство существует, метод возвращает true, иначе — false. Метод __unset() удаляет 
//свойство name из объекта $myObject.
?&gt;
</pre>
<br>
<li>
__call() и __callStatic(): Применяются для обработки вызовов методов, которые могут быть недоступны
или неопределены. Позволяют динамически выполнять методы, добавляя гибкость классу.    
</li>
<p>
Пример использования методов __call() и __callStatic():    
</p>
<pre>
&lt;?php
class MyClass {
public function __call($methodName, $arguments) {
echo "Попытка вызова метода '$methodName' с аргументами: ". implode(", ", $arguments). "\n";
}

public static function __callStatic($methodName, $arguments) {
echo "Попытка вызова статического метода '$methodName' с аргументами: ". implode(", ", $arguments). "\n";
}
}

$myObject = new MyClass();
$myObject->nonExistentMethod("arg1", "arg2"); // Вызов несуществующего метода

MyClass::nonExistentStaticMethod("arg1", "arg2"); // Вызов несуществующего статического метода

//В этом примере при попытке вызова несуществующего метода для объекта $myObject будет вызван метод __call(),
// который выведет информацию о попытке вызова. Аналогично, при попытке вызова несуществующего 
//статического метода для класса MyClass будет вызван метод __callStatic(), который также выведет 
//информацию о попытке вызова.
?&gt;
</pre>
<br>
<li>
__toString(): Вызывается, когда объект обрабатывается как строка, например, при использовании 
функций echo или print. Позволяет определить строковое представление объекта.    
</li>
<p>
Пример использования метода __toString():    
</p>
<pre>
&lt;?php
class MyClass {
public function __toString() {
return "Это объект типа MyClass.";
}
}

$myObject = new MyClass();
echo $myObject; // Вызов метода __toString() для преобразования объекта в строку

//Метод __toString() полезен при работе с объектами, которые должны быть представлены в виде строк,
//например, при логировании или сериализации объектов.
?&gt;
</pre>
</ol>
<p>
Важно помнить, что все магические методы должны быть объявлены публичными (public), имеют 
предопределённые параметры и могут возвращать различные значения в зависимости от своего назначения.    
</p>


<pre>
&lt;?php

?&gt;
</pre>

<pre>
&lt;?php

?&gt;
</pre>

<pre>
&lt;?php

?&gt;
</pre>

<pre>
&lt;?php

?&gt;
</pre>

</body>
</html>