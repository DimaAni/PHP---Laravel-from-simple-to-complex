<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    body {
        background-color: wheat;
        color: black;
    }

    pre {
        color: red;
    }

    .ul pre {
        font-size: 18px;
        color: black;
    }
    
    </style>
    <title>Глава. 6</title>
</head>
<body>
    <h1>Полезные приемы и операции</h1>
    <p>Обсудим то что не вошло в предущие главы. Но все же явдяются нужными и полезными.</p>
    <h2>Ссылки</h2>
    <p>
    Cсылки позволяют ссылаться на область памяти, где расположено значение переменной или параметра.
    Для создания ссылки перед переменной указывается символ амперсанда - &.
    </p>
    <p>Пример создания ссылки:</p>
    <pre>
&lt;?php
$bim = "Bim";
$bom = &$bim; // передача ссылки
$bom = "Bom";
echo "bim = $bim <br>"; // bim = Bom
echo "bom = $bom"; // bom = Bom


//Сначала создаётся переменная $bim со значением "Bim". Затем создаётся вторая переменная $bom, 
//которой передаётся ссылка на $bim с помощью символа амперсанда (&). Это означает, что изменение
//значения одной переменной приведёт к изменению другой, так как они указывают на одну и ту же 
//область в памяти.После этого значение $bom изменяется на "Bom", что также изменяет значение 
//$bim, поскольку они связаны через ссылку. В результате оба echo выводят "Bom".
?&gt;
</pre>
<p>
Пример передачи параметра по ссылке:
</p>

<pre>
&lt;?php
function square(&$a) {
 $a *= $a;
echo "a = $a";
}

$number = 5;
square($number);
echo "<br />number = $number";

//Функция square() принимает параметр по ссылке, используя знак амперсанда перед параметром.
//Внутри функции значение параметра возводится в квадрат, что изменяет значение переменной 
//$number, переданной в функцию.Возвращение ссылки из функции:
Функция также может возвращать ссылку. Для этого перед определением функции и 
её вызовом указывается символ амперсанда.
?&gt;
</pre>
<p>
Пример возвращения ссылки из функции:
</p>

<pre>
&lt;?php
function &checkName(&$name) {
if($name === "admin") $name = "Петр";
return $name;
}

$userName = "admin";
$checkedName = &checkName($userName);
echo "<br />userName: $userName";
echo "<br />checkedName: $checkedName";



//Функция checkName() получает параметр по ссылке и возвращает ссылку на него. 
//После вызова функции переменная $checkedName фактически содержит ссылку на переменную $userName.
?&gt;
</pre>
<hr>
<br>
<h2>Константы.</h2>
<p>
    Константы отличаются от переменных тем что их значения изменить нельзя.
</p>
<p>
    Чтобы длбавить константу применяется конструкция  define(). Первым арг-м ф-ии 
    передается текст с названием константы. Вторым арг-м указывается ее значение.
    В начале названия константы $ не указывается. Чтобы не запутаться название константы пишется 
    с большой буквы.
</p>
<p>
    Также после создания костанты ее нельзя удалить. Если нужно проверить наличия константы - 
    использется ф-я defined( ). Аргументом внутри круглых скобок указывается текст с именем 
    константы которую мы проверяем. В результате будет true или false в зависимости от того
    определена константа или нет.
</p>
<p>
    Есть еще один способ добавить константу. Для этого использем ключевое слово const. 
    После него указываем название константы(без $) и через оператор присваивания значение 
    константы.
</p>
<p>
В PHP разница между использованием define() и const заключается в следующем:
</p>
<p>
define(): Используется для определения констант с произвольным выражением.
</p>
<p>
const: Позволяет определить константы только для скалярных выражений 
(например, int, float, bool, string) и массивов, содержащих только скалярные выражения.
</p>
<p>
Область видимости:
</p>
<p>
define(): Константы, определенные через define(), могут быть доступны в любом месте 
кода без учета области видимости.
</p>
<p>
const: Константы, объявленные через const, должны быть определены в самой верхней области 
видимости, так как они обрабатываются во время компиляции. Это означает, что их нельзя 
объявить внутри функций, циклов, условий и т.д.
</p>
<p>
Изменение и удаление:
</p>
<p>
define(): Позволяет определить константу с произвольным выражением, которое не может 
быть изменено или удалено после первоначального объявления.
</p>
<p>
const: Константы, определенные через const, являются частью исходного кода и не могут 
быть изменены или удалены после объявления.
</p>
<p>
Использование:
</p>
<p>
define(): Подходит для определения констант с произвольными значениями, которые могут 
потребоваться в различных частях кода.
</p>
<p>
const: Лучше использовать для определения констант с простыми скалярными значениями 
или массивами, которые не требуют сложных вычислений.
</p>
<p>
Таким образом, выбор между define() и const зависит от типа данных, которые вы хотите 
определить как константу, и от того, как вы планируете использовать эту константу в вашем коде.
</p>

<pre>
&lt;?php
// Пример использования define()
define("PI", 3.14);
echo PI; // Выведет 3.14

// Пример использования const
const MY_CONSTANT = 'Hello, World!';
echo MY_CONSTANT; // Выведет Hello, World!

// Пример использования define() для создания константы с выражением
define("AREA", M_PI * pow(10, 2));
echo AREA; // Выведет примерно 314.159

// Пример использования const для создания массива констант
const FRUITS = array('apple', 'banana', 'cherry');
echo FRUITS[0]; // Выведет apple
?&gt;
</pre>
<h3>Еще немного о константах</h3>
<p>Кроме define() и const в PHP существуют встроенные константы.</p>
<p>Их название начинается и заканчиваются двойным подчеркиванием</p>
<p>
    __LINE__  - можно узнать текущий номер строки в файле.
</p>
<p>
    __FILE__  - позволяет узнать название файла. 
</p>
<p>
    __DIR__  - название директории в которой находится файл.
</p>
<p>
    __FUNCTION__  - можно узнать название функции к которой происходит обращение.
</p>
<hr>
<br>
<h2>Глобальные переменные</h2>
<p>
Глобальные переменные в PHP доступны во всех функциях и областях видимости. 
По умолчанию, если объявим переменную внутри функции, она является локальной
и доступна только внутри этой функции. Однако, если нужно получить доступ к 
переменной за пределами функции, где она была объявлена, или изменить её значение, 
можем использовать ключевое слово global, чтобы сделать переменную глобальной.
</p>
<pre>
&lt;?php
$name = "Дима"; // Глобальная переменная

function myFunction() {
 global $name; // Объявляем, что хотим использовать глобальную переменную $name
 echo "Привет, " . $name; // Выводим значение глобальной переменной
}

myFunction(); // Выведет "Привет, Дима"
?&gt;
</pre>
<p>
Также можно использовать встроенный массив $GLOBALS, который содержит все глобальные 
переменные в виде пар ключ-значение, где ключом является имя переменной. Это позволяет 
получить доступ к глобальной переменной без использования global.
</p>

<pre>
&lt;?php
$name = "Александр"; // Глобальная переменная

function myFunction() {
 echo "Привет, " . $GLOBALS['name']; // Получаем значение глобальной переменной через $GLOBALS
}

myFunction(); // Выведет "Привет, Александр"
?&gt;
</pre>
<p>
Запомним, что использование глобальных переменных может привести к трудностям в 
поддержке кода и ошибкам, связанным с конфликтами имён переменных. Поэтому рекомендуется
использовать локальные переменные и передавать значения между функциями через аргументы 
и возвращаемые значения.
</p>
<hr>
<br>
<h2>
    Статические переменные.
</h2>
<p>
    Такие переменные объявляются с ключевым словом static. Особенность таких пере-х в том,
    что они не удаляются из памяти и после прекращения работы ф-ии при последующем вызове 
    ипользуются используется одна и таже пере-я.
</p>
<p>Пример статические пер-е:</p>
<pre>
&lt;?php
function calc() {

// Статическая пер-я:
static $value=0;
$value+=100;
return $value;
}
// Вызов ф-ии в операторе цикла

for ($k=1; $k<=5;$k++) {
    echo "[$k] calk() -> ", calc(),"\n"
}

//В результате будет так:
[1] calc() -> 100
[2] calc() -> 200
[3] calc() -> 300
[4] calc() -> 400
[5] calc() -> 500
?&gt;
</pre>
<p>
Функция calc() использует статическую переменную $value, которая инициализируется 
значением 0 при первом вызове функции. Каждый последующий вызов увеличивает значение
$value на 100 и возвращает его. В цикле for функция calc() вызывается пять раз, 
каждый раз увеличивая значение на 100.
</p>
<hr>
<br>
<h2>Многострочный текст</h2>
<p>
    Существует несколько способов их содания. Наппример такая синтакситечкая конструкция. 
</p>
<p>
    После инструкции <<< указывается идентификатор и затем проихводится переход к следующей строке.
</p>
<p>
    Далее идет текст без кавычек, который может занимать немколшко строк.
</p>
<p>
    Заканчивается эта конструкция темже индефикатором как и начиналась и далее ;
</p>
<p>
    Это должна быть последняя инструкция в строке и больше никаких дополнительных символов.
</p>
<p>
Есть еще способ создания многострочного текста. Разница от предыдущего в том, что начальный 
идентификатор после инструкции <<< заключается в одинарные кавычки. 
</p>
<pre>
&lt;?php
// Многострочный текст:
$text=<<<'MYTEXT'
Пример программного кода:
 $number=123; // Создание переменной
echo "\$number = ",$number,"\n";
MYTEXT;
echo $text;

//Результат выполнения будет таким:
$number=123; // Создание переменной
echo "\$number = ",$number,"\n";
?&gt;
</pre>
<hr>
<br>
<h2>Работа с файлами.</h2>
<p>
Для работы с файлами используются функции fopen(), fread(), fwrite(), fclose() и другие.
</p>
<p>
Функция fopen() открывает файл и возвращает дескриптор файла. 
</p>
<p>Синтаксис:</p>
<p>
$file = fopen('путь/к/файлу', 'режим');
</p>
<p>
Режимы открытия файла:
'r'  —  чтение;
<br>
'w'  —  запись (создаёт файл, если его нет);
<br>
'a'  —  добавление (открывает файл для добавления в конец);
<br>
'r+'  —  чтение и запись;
<br>
'w+'  —  чтение и запись, создаёт файл, если его нет.
</p>
<p>
После завершения работы с файлом его нужно закрыть с помощью функции fclose(), 
передав ей дескриптор файла: fclose($file);
</p>
<p>
Для чтения содержимого файла используется функция fread(), которая 
считывает указанное количество символов из файла:
</p>
<p>
$content = fread($file, $count);
Здесь $file — дескриптор файла, $count — количество символов для чтения.
</p>
<p>
Для записи данных в файл используется функция fwrite(), которая записывает строку в файл:
fwrite($file, $data);
Здесь $file — дескриптор файла, $data — строка для записи.
</p>
<p>
Также можно использовать функцию file_get_contents() для чтения всего содержимого файла сразу:
$content = file_get_contents('путь/к/файлу');
<br>
И функцию file_put_contents() для записи данных в файл:
file_put_contents('путь/к/файлу', $data);
Здесь $data — строка для записи, 'путь/к/файлу' — путь к файлу.
</p>
<p>Примеры использования функций для работы с файлами.</p>
<p>1.Чтение содержимого.</p>
<pre>
&lt;?php
$filename = 'example.txt';
$file = fopen($filename, 'r');

if ($file) {
$content = fread($file, filesize($filename));
fclose($file);
echo $content;
} else {

echo "Не удалось открыть файл.";
}
?&gt;
</pre>

<p>2.Запись данных в файл:</p>
<pre>
&lt;?php
$filename = 'example.txt';
$file = fopen($filename, 'w');
if ($file) {
$content = "Пример текста для записи в файл.";
fwrite($file, $content);
fclose($file);

echo "Данные успешно записаны.";

} else {
echo "Не удалось открыть файл.";
}
?&gt;
</pre>
<p>3.Использование file_get_contents() для чтения файла:</p>

<pre>
&lt;?php
$filename = 'example.txt';
$content = file_get_contents($filename);
if ($content !== false) {

echo $content;
} else {

echo "Не удалось прочитать файл.";
}
?&gt;
</pre>
<p>4.Использование file_put_contents() для записи данных в файл:</p>
<pre>
&lt;?php
$filename = 'example.txt';
$content = "Пример текста для записи в файл.";

if (file_put_contents($filename, $content) !== false) {

    echo "Данные успешно записаны.";
} else {

    echo "Не удалось записать данные в файл.";
}
?&gt;
</pre>
<hr>
<br>
<h2>Включение файла в программу.</h2>
<p>Для включения файла в программу на PHP используются следующие конструкции:</p>
<pre>
include — включает и выполняет указанный файл. Если файл не найден, генерируется предупреждение.
include 'script.php';
<br>
require — работает аналогично include, но при ошибке загрузки файла выполнение скрипта 
останавливается с фатальной ошибкой.
require 'script.php';
<br>
include_once и require_once — включают файл только один раз, предотвращая повторное 
включение одного и того же файла. Это полезно для избежания ошибок при повторном включении 
одного и того же кода.
include_once 'script.php';
require_once 'script.php';
<br>
При использовании этих конструкций важно помнить, что включаемые файлы должны содержать 
корректный PHP-код, иначе они не будут выполнены. Также стоит обратить внимание на пути к файлам:
они должны быть указаны относительно текущего местоположения скрипта.
</pre>
<hr>
<br>
<h2>Вспомним что проходили в 6 главе.</h2>
<ul class="ul">
    <li>
        Ссылки - для альтернативного доступа к переменным.Если мы создали ссылку на 
        переменную, то ей присваивается эта переменная предвареная инструкцией &. 
        И это будет называться жесткой ссылкой. 
    </li>
    <br>
    <li>
        Для применения мягкой ссылки некоторой пере-й в кач-ве значения присваивания текст с названием
        другой пере-й(без символа $). Добавление второго символа $ к названию пер-ой, дает доступ
        к пер-ой, текст с именем которой присвоен первой пер-ой
    </li>
    <br>
    <li>
        Кроме пере-х существуют константы. Их значения после первого присваивания изменить нельзя.
        Их можно создать при помощи ф-ии define() или же инструкции const. Также в PHP есть встроеные
        константы.
    </li>
    <br>
    <li>
        Глобальные пере-ные могут применятся в фун-ях. Также они доступны и вне области ф-ии. 
        В теле ф-ии такие переменные объявляются инструкцией global.  
    </li>
    <li>
    Статические пер-е могут использоваться в ф-ях. Статическая переменная создается и получает
    значение при первом вызове ф-ии. После заверщения работы ф-ии статическая пер-я остается в
    памяти и при следущем вызове ф-ии эта пере-я ипользуется снова. 
    </li>
    <br>
    <li>
    Многострочный текст. Для работы с многострочным текстом пер-й присваиваится выражение, которое
    начинается с инструкции <<< .
</li>
<br>
<li>
Работа с файлами имется большое количесство ф-ий, к примеру такие как - fopen(), fread(),
fwrite(), fclose() .
</li>
<br>
<li>
<pre>Включение файла в программу. 
include — включает и выполняет указанный файл. Если файл не найден, генерируется предупреждение.
require — работает аналогично include, но при ошибке загрузки файла выполнение скрипта 
останавливается с фатальной ошибкой.
include_once и require_once — включают файл только один раз, предотвращая повторное 
включение одного и того же файла. 
</pre>
</li>
</ul>

</body>
</html>